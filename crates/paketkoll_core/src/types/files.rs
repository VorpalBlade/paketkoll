//! Common types for representing data about files

use std::{path::PathBuf, sync::atomic::AtomicBool, time::SystemTime};

use super::PackageRef;

/// A regular file with just checksum info (as Debian gives us)
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub(crate) struct RegularFileBasic {
    pub size: Option<u64>,
    pub checksum: Checksum,
}

/// A regular file with all info (as Arch Linux has)
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub(crate) struct RegularFile {
    pub mode: Mode,
    pub owner: Uid,
    pub group: Gid,
    pub size: u64,
    pub mtime: SystemTime,
    pub checksum: Checksum,
}

/// A regular file with all info (as Arch Linux has)
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub(crate) struct RegularFileSystemd {
    pub mode: Mode,
    pub owner: Uid,
    pub group: Gid,
    pub size: Option<u64>,
    pub checksum: Checksum,
}

/// A FIFO
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub(crate) struct Fifo {
    pub mode: Mode,
    pub owner: Uid,
    pub group: Gid,
}

/// A device node
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub(crate) struct DeviceNode {
    pub mode: Mode,
    pub owner: Uid,
    pub group: Gid,
    pub device_type: DeviceType,
    pub major: u64,
    pub minor: u64,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub(crate) enum DeviceType {
    Block,
    Char,
}

/// A symlink
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub(crate) struct Symlink {
    pub owner: Uid,
    pub group: Gid,
    /// Note: May be a relative path
    pub target: PathBuf,
}

/// A directory
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub(crate) struct Directory {
    pub mode: Mode,
    pub owner: Uid,
    pub group: Gid,
}

/// A file entry from the package database
#[derive(Debug)]
#[non_exhaustive]
pub(crate) struct FileEntry {
    /// Package this file belongs to
    pub package: Option<PackageRef>,
    pub path: PathBuf,
    pub properties: Properties,
    pub flags: FileFlags,
    /// Which provider this came from
    pub source: &'static str,
    /// Used to handle finding missing files when checking for unexpected files
    pub(crate) seen: AtomicBool,
    // Has one byte of padding left over for something else
}

impl Clone for FileEntry {
    fn clone(&self) -> Self {
        Self {
            package: self.package,
            path: self.path.clone(),
            properties: self.properties.clone(),
            flags: self.flags,
            source: self.source,
            seen: self.seen.load(std::sync::atomic::Ordering::Relaxed).into(),
        }
    }
}

impl PartialEq for FileEntry {
    fn eq(&self, other: &Self) -> bool {
        self.package == other.package
            && self.path == other.path
            && self.properties == other.properties
            && self.flags == other.flags
    }
}

bitflags::bitflags! {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
    pub(crate) struct FileFlags : u16 {
        const CONFIG = 0b0000_0000_0000_0001;
        const OK_IF_MISSING = 0b0000_0000_0000_0010;
    }
}

/// File properties from the package database
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "snake_case"))]
pub(crate) enum Properties {
    /// A regular file with just checksum info (as Debian gives us)
    RegularFileBasic(RegularFileBasic),
    /// A regular file with info that systemd provides
    RegularFileSystemd(RegularFileSystemd),
    /// A regular file with all info (as Arch Linux has)
    RegularFile(RegularFile),
    Symlink(Symlink),
    Directory(Directory),
    Fifo(Fifo),
    DeviceNode(DeviceNode),
    /// This is some unknown thing that is not a file or directory
    Special,
    /// An entry that shouldn't exist (being actively removed)
    Removed,
    /// If the package management system doesn't give us enough info,
    /// all we know is that it should exist.
    Unknown,
    /// We don't know what it is, just what permissions it should have
    /// (can be generated by systemd-tmpfiles)
    Permissions(Permissions),
}

impl Properties {
    pub(crate) fn is_dir(&self) -> Option<bool> {
        match self {
            Properties::RegularFileBasic(_) => Some(false),
            Properties::RegularFileSystemd(_) => Some(false),
            Properties::RegularFile(_) => Some(false),
            Properties::Symlink(_) => Some(false),
            Properties::Directory(_) => Some(true),
            Properties::Special => Some(false),
            Properties::Fifo(_) => Some(false),
            Properties::DeviceNode(_) => Some(false),
            Properties::Removed => None,
            Properties::Unknown => None,
            Properties::Permissions(_) => None,
        }
    }
}

/// Unix file mode (permissions)
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Mode(pub u32);

impl Mode {
    pub fn new(value: u32) -> Self {
        Self(value)
    }
}

impl std::fmt::Display for Mode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:o}", self.0)
    }
}

/// A POSIX UID
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Uid(pub u32);

impl Uid {
    pub fn new(id: u32) -> Self {
        Self(id)
    }
}

impl std::fmt::Display for Uid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

/// A POSIX GID
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Gid(pub u32);

impl Gid {
    pub fn new(id: u32) -> Self {
        Self(id)
    }
}

impl std::fmt::Display for Gid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}
/// A set of permissions
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub(crate) struct Permissions {
    pub mode: Mode,
    pub owner: Uid,
    pub group: Gid,
}

/// Represents a checksum of a file
///
/// Which checksum types are used depend on the feature flags.
/// For example currently: Arch uses SHA256, and Debian uses MD5.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[cfg_attr(feature = "serde", serde(rename_all = "snake_case"))]
#[non_exhaustive]
pub enum Checksum {
    #[cfg(feature = "__md5")]
    #[cfg_attr(
        feature = "serde",
        serde(serialize_with = "crate::utils::buffer_to_hex")
    )]
    Md5([u8; 16]),
    #[cfg(feature = "__sha256")]
    #[cfg_attr(
        feature = "serde",
        serde(serialize_with = "crate::utils::buffer_to_hex")
    )]
    Sha256([u8; 32]),
}

impl std::fmt::Display for Checksum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            #[cfg(feature = "__md5")]
            Self::Md5(value) => write!(f, "md5:{}", faster_hex::hex_string(value)),
            #[cfg(feature = "__sha256")]
            Self::Sha256(value) => write!(f, "sha256:{}", faster_hex::hex_string(value)),
        }
    }
}
